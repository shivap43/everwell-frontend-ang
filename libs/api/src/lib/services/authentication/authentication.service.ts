/**
 * Authentication API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: 0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* eslint-disable no-unused-vars, @typescript-eslint/no-unused-vars, @typescript-eslint/member-ordering */

import { HttpClient, HttpEvent, HttpHeaders, HttpParams, HttpResponse } from "@angular/common/http";
import { Inject, Injectable, Optional } from "@angular/core";

import { Observable, BehaviorSubject } from "rxjs";
import { Configuration } from "../configuration";
import { CustomHttpUrlEncodingCodec } from "../encoder";

import { BASE_PATH } from "../variables";

import {
    Csrf,
    LoginResponse,
    MaskedVerification,
    TpiSsoResponse,
    VerificationMethod,
    HeadsetSSO,
    MemberDetails,
    AssociatedAccount,
    AgentSelfEnrollmentSSO,
    PermissionsModel,
} from "./models";
import { shareReplay } from "rxjs/operators";
import { Credential } from "@empowered/constants";
import { UserSSO } from "./models/userSSO.model";

export interface SendOneTimePassPayload {
    groupId?: number;
    memberId?: number;
    sendToEmail?: string;
    sendToPhone?: string;
}

@Injectable({
    providedIn: "root",
})
export class AuthenticationService {
    defaultHeaders = new HttpHeaders();
    protected basePath = "/api";
    formValue = new BehaviorSubject(0);

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, private configuration: Configuration) {
        this.configuration.basePath = configuration.basePath || basePath || this.basePath;
    }

    /**
     *
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    acceptConsent(observe?: "body", reportProgress?: boolean): Observable<any>;

    acceptConsent(observe?: "response", reportProgress?: boolean): Observable<HttpResponse<any>>;

    acceptConsent(observe?: "events", reportProgress?: boolean): Observable<HttpEvent<any>>;

    acceptConsent(observe: any = "body", reportProgress: boolean = false): Observable<any> {
        let headers = this.defaultHeaders;

        // authentication (session) required
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [];

        return this.httpClient.post<any>(`${this.configuration.basePath}/auth/consent`, null, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress,
        });
    }

    /**
     *
     * start new unauthenticated session and recieve CSRF token to make authentication call
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    csrf(observe?: "body", reportProgress?: boolean): Observable<Csrf>;

    csrf(observe?: "response", reportProgress?: boolean): Observable<HttpResponse<Csrf>>;

    csrf(observe?: "events", reportProgress?: boolean): Observable<HttpEvent<Csrf>>;

    csrf(observe: any = "body", reportProgress: boolean = false): Observable<any> {
        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = ["application/json"];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [];
        return this.httpClient.get<Csrf>(`${this.configuration.basePath}/auth/csrf`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress,
        });
    }

    /**
     *
     *
     * @param username
     * @param communicationMethod
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    forgotPassword(username: string, communicationMethod?: VerificationMethod, observe?: "body", reportProgress?: boolean): Observable<any>;

    forgotPassword(
        username: string,
        communicationMethod?: VerificationMethod,
        observe?: "response",
        reportProgress?: boolean,
    ): Observable<HttpResponse<any>>;

    forgotPassword(
        username: string,
        communicationMethod?: VerificationMethod,
        observe?: "events",
        reportProgress?: boolean,
    ): Observable<HttpEvent<any>>;

    forgotPassword(
        username: string,
        communicationMethod?: VerificationMethod,
        observe: any = "body",
        reportProgress: boolean = false,
    ): Observable<any> {
        if (username === null || username === undefined) {
            throw new Error("Required parameter username was null or undefined when calling forgotPassword.");
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (username !== undefined && username !== null) {
            queryParameters = queryParameters.set("username", username as any);
        }
        if (communicationMethod !== undefined && communicationMethod !== null) {
            queryParameters = queryParameters.set("communicationMethod", communicationMethod as any);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = ["application/json"];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [];

        return this.httpClient.post<MaskedVerification>(`${this.configuration.basePath}/admins/forgotPassword`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: "response",
            reportProgress: reportProgress,
        });
    }

    /**
     *
     *
     * @param verifyMethod
     * @param value
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    forgotUsername(verifyMethod?: string, value?: string, observe?: "body", reportProgress?: boolean): Observable<any>;

    forgotUsername(verifyMethod?: string, value?: string, observe?: "response", reportProgress?: boolean): Observable<HttpResponse<any>>;

    forgotUsername(verifyMethod?: string, value?: string, observe?: "events", reportProgress?: boolean): Observable<HttpEvent<any>>;

    forgotUsername(verifyMethod?: string, value?: string, observe: any = "body", reportProgress: boolean = false): Observable<any> {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        queryParameters = queryParameters.set(verifyMethod?.toLowerCase() ?? "", value ?? "");
        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [];

        return this.httpClient.post<any>(`${this.configuration.basePath}/admins/forgotUsername`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress,
        });
    }

    /**
     *
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    keepalive(observe?: "body", reportProgress?: boolean): Observable<any>;

    keepalive(observe?: "response", reportProgress?: boolean): Observable<HttpResponse<any>>;

    keepalive(observe?: "events", reportProgress?: boolean): Observable<HttpEvent<any>>;

    keepalive(observe: any = "body", reportProgress: boolean = false): Observable<any> {
        let headers = this.defaultHeaders;

        // authentication (session) required
        // to determine the Accept header
        const httpHeaderAccepts: string[] = [];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [];

        return this.httpClient.head<any>(`${this.configuration.basePath}/auth/keepalive`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress,
        });
    }

    /**
     *
     * Authenticate an unauthenticated session
     * @param portal name of the portal that the user is currently in
     * @param credential optional credential object containing the username and password
     * @param mpGroup optional group ID that allows logging in to specific group
     * @returns observable of login response
     */
    login(portal: string, credential?: { username: string; password: string }, mpGroup?: string): Observable<LoginResponse> {
        let headers = new HttpHeaders();
        headers = headers.set("mp-portal", portal.toString());
        if (!mpGroup) {
            this.configuration.username = credential?.username;
            this.configuration.password = credential?.password;
            // authentication (basic) required
            if (this.configuration.username || this.configuration.password) {
                headers = headers.set("Authorization", "Basic " + btoa(this.configuration.username + ":" + this.configuration.password));
            }
        } else {
            headers = headers.set("MP-Group", mpGroup ? mpGroup.toString() : "");
        }
        return this.httpClient.post<LoginResponse>(`${this.configuration.basePath}/auth/login`, null, {
            withCredentials: this.configuration.withCredentials,
            headers,
        });
    }

    /**
     *
     * authenticate an producer via SSO
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    producerSSO(body?: string, observe?: "body", reportProgress?: boolean): Observable<Credential>;

    producerSSO(body?: string, observe?: "response", reportProgress?: boolean): Observable<HttpResponse<Credential>>;

    producerSSO(body?: string, observe?: "events", reportProgress?: boolean): Observable<HttpEvent<Credential>>;

    producerSSO(body?: string, observe: any = "body", reportProgress: boolean = false): Observable<any> {
        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = ["application/json"];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = ["text/plain"];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<Credential>(`${this.configuration.basePath}/auth/sso/producer`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress,
        });
    }

    /**
     * Starts registration
     * @param [portal]
     * @param [email]
     * @param [phone]
     * @param [observe] set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param [reportProgress] flag to report request and response progress.
     * @returns registration
     */
    startRegistration(portal?: string, email?: string, phone?: string, observe?: "body", reportProgress?: boolean): Observable<Credential>;

    startRegistration(
        portal?: string,
        email?: string,
        phone?: string,
        observe?: "response",
        reportProgress?: boolean,
    ): Observable<HttpResponse<Credential>>;

    startRegistration(
        portal?: string,
        email?: string,
        phone?: string,
        observe?: "events",
        reportProgress?: boolean,
    ): Observable<HttpEvent<Credential>>;

    startRegistration(
        portal?: string,
        email?: string,
        phone?: string,
        observe: any = "body",
        reportProgress: boolean = false,
    ): Observable<any> {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (email) {
            queryParameters = queryParameters.set("email", email as any);
        }
        if (phone) {
            queryParameters = queryParameters.set("phone", phone as any);
        }
        let headers = this.defaultHeaders;
        // to determine the Accept header
        const httpHeaderAccepts: string[] = ["application/json"];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }
        if (portal) {
            headers = headers.set("mp-portal", portal.toString());
        }

        // to determine the Content-Type header
        const consumes: string[] = [];

        return this.httpClient.post<Credential>(`${this.configuration.basePath}/admins/startRegistration`, null, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress,
        });
    }
    /**
     *
     * authenticate a producer to assist a TPI user via SSO
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    tpiAssistedSSO(body?: string, observe?: "body", reportProgress?: boolean): Observable<TpiSsoResponse>;

    tpiAssistedSSO(body?: string, observe?: "response", reportProgress?: boolean): Observable<HttpResponse<TpiSsoResponse>>;

    tpiAssistedSSO(body?: string, observe?: "events", reportProgress?: boolean): Observable<HttpEvent<TpiSsoResponse>>;

    tpiAssistedSSO(body?: string, observe: any = "body", reportProgress: boolean = false): Observable<any> {
        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = ["application/json"];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = ["text/plain"];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TpiSsoResponse>(`${this.configuration.basePath}/auth/sso/tpiAssisted`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress,
        });
    }

    /**
     *
     * authenticate a TPI user via SSO
     * @param body
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    tpiSSO(body?: string, observe?: "body", reportProgress?: boolean): Observable<TpiSsoResponse>;

    tpiSSO(body?: string, observe?: "response", reportProgress?: boolean): Observable<HttpResponse<TpiSsoResponse>>;

    tpiSSO(body?: string, observe?: "events", reportProgress?: boolean): Observable<HttpEvent<TpiSsoResponse>>;

    tpiSSO(body?: string, observe: any = "body", reportProgress: boolean = false): Observable<any> {
        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = ["application/json"];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = ["text/plain"];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<TpiSsoResponse>(`${this.configuration.basePath}/auth/sso/tpi`, body, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress,
        });
    }

    /**
     *
     *
     * @param token string value of auth token
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    verifyAuthToken(token: string, observe?: "body", reportProgress?: boolean): Observable<any>;

    verifyAuthToken(token: string, observe?: "response", reportProgress?: boolean): Observable<HttpResponse<any>>;

    verifyAuthToken(token: string, observe?: "events", reportProgress?: boolean): Observable<HttpEvent<any>>;

    verifyAuthToken(token: string, observe: any = "body", reportProgress: boolean = false): Observable<any> {
        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = ["application/json"];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<{ token: string }>(
            `${this.configuration.basePath}/auth/verifyAuthToken`,
            { token },
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress,
            },
        );
    }
    /**
     * for self-service, verify auth token and login
     * @param token auth token value
     * @param mpGroup - mpGroup value for post account selection call
     * @returns observable of login response
     */
    verifyTokenAndLogin(token: string, mpGroup?: number): Observable<LoginResponse> {
        let headers = new HttpHeaders();
        headers = headers.set("MP-Group", mpGroup ? mpGroup.toString() : "");
        return this.httpClient.post<LoginResponse>(
            `${this.configuration.basePath}/auth/sso/selfEnrollment/verifyTokenAndLogin`,
            { token },
            { headers },
        );
    }

    logout(): any {
        sessionStorage.clear();
        return this.httpClient.post<any>(`${this.configuration.basePath}/auth/logout`, {});
    }

    resetPassword(password: string, token: string): any {
        return this.httpClient.post<any>(`${this.configuration.basePath}/auth/resetPassword`, { password, token });
    }

    permissions$ = this.httpClient.get<PermissionsModel[]>(`${this.configuration.basePath}/auth/permissions`).pipe(shareReplay(1));

    getPermissions(): Observable<string[]> {
        return this.httpClient.get<string[]>(`${this.configuration.basePath}/auth/permissions`);
    }

    setPassword(password: string, token: string, mfaPreferred: boolean): any {
        return this.httpClient.post<any>(
            `${this.configuration.basePath}/auth/setPassword`,
            {
                password,
                token,
                mfaPreferred,
            },
            { observe: "response" },
        );
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = "multipart/form-data";
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    verifyHeadsetLink(guid: string, groupId: number): Observable<any> {
        return this.httpClient.post(`${this.configuration.basePath}/auth/verifyHeadsetLink`, { guid, groupId }, { observe: "response" });
    }

    getHeadsetSSO(headsetSSO: HeadsetSSO): Observable<MemberDetails[]> {
        return this.httpClient.post<MemberDetails[]>(`${this.configuration.basePath}/auth/sso/headset`, headsetSSO);
    }

    verifyLink(guid: string, groupId: number): Observable<HttpResponse<any>> {
        return this.httpClient.post(`${this.configuration.basePath}/auth/verifyEventRequest`, { guid, groupId }, { observe: "response" });
    }

    getUserSSO(userSSO: UserSSO): Observable<MemberDetails[]> {
        return this.httpClient.post<MemberDetails[]>(`${this.configuration.basePath}/auth/sso/eventRequest`, userSSO);
    }

    /**
     * Returns associated account information if member is part of multiple accounts
     * @param username the member's username
     * @returns observable of accounts the member is associated with
     */
    getAssociatedAccounts(): Observable<AssociatedAccount[]> {
        const headers = new HttpHeaders();
        return this.httpClient.get<AssociatedAccount[]>(`${this.configuration.basePath}/auth/associatedAccounts`, {
            headers,
        });
    }
    /**
     * Get Token for agent self enrollment
     * @param mpGroup current agent self enrollment group Id.
     * @returns: Observable<string> - the token string
     */
    getAgentSelfEnrollmentToken(mpGroup: string): Observable<string> {
        const headers = new HttpHeaders().set("MP-Group", mpGroup ? mpGroup.toString() : "");
        return this.httpClient.get(`${this.configuration.basePath}/auth/sso/producer/selfenrollment/token`, {
            headers: headers,
            responseType: "text",
        });
    }
    /**
     * method for agent self-enrollment SSO
     * @param token: string - required token for SSO
     * @returns: Observable<AgentSelfEnrollmentSSO> - user details after SSO
     */
    agentSelfEnrollmentSSO(token: string): Observable<AgentSelfEnrollmentSSO> {
        return this.httpClient.post<AgentSelfEnrollmentSSO>(`${this.configuration.basePath}/auth/sso/producer/selfenrollment`, token);
    }

    /**
     * Sends one time pass
     * @param [sendToEmail] contains the email Id to which one time pass will be sent
     * @param [sendToPhone] contains the phone number to which one time pass will be sent
     * @param [groupId]
     * @param [memberId]
     * @returns one time pass
     */
    sendOneTimePass(sendToEmail?: string, sendToPhone?: string, groupId?: number, memberId?: number): Observable<void> {
        let payload: SendOneTimePassPayload = {};
        if (sendToEmail) {
            payload = {
                sendToEmail,
            };
        }
        if (sendToPhone) {
            payload = {
                sendToPhone,
            };
        }
        return this.httpClient.post<void>(`${this.configuration.basePath}/auth/oneTimePass/selfService/send`, payload, {
            withCredentials: this.configuration.withCredentials,
        });
    }
    /**
     * method to resume aflac session
     * @param mpGroup - mpGroup value for post account selection call
     * @returns observable of login response
     */
    resume(mpGroup?: number, isMpGroupRequired?: boolean): Observable<LoginResponse> {
        let headers = new HttpHeaders();
        if (isMpGroupRequired) {
            headers = headers.set("MP-Group", mpGroup ? mpGroup.toString() : "");
        }
        return this.httpClient.post<LoginResponse>(`${this.configuration.basePath}/auth/aflac/resume`, null, {
            withCredentials: this.configuration.withCredentials,
            headers,
        });
    }

    /**
     * returns the MyGuide token
     * @returns string observable of the MyGuide token
     */
    getMyGuideToken(): Observable<string> {
        return this.httpClient.get(`${this.configuration.basePath}/auth/myGuideToken`, {
            responseType: "text",
        });
    }
}
